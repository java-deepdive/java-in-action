## [2021.01.25 - 스터디 2주차]

### DONE

- StringBuffer
  - 코드 리뷰

### TODO
- 차주 진도
  - `HashTable`, `ArrayList` 구현해보기
  - 자료구조 > 02. 연결리스트 내용읽기

- HashTable
  - 해싱과 해싱 함수
  - 충돌에 대한 대처법
  
- LinkedList
  - 단방향
  - 양방향
  - 참조 값에 대한 포인터 관리 방법

### Feedback

- StringBuffer
  - `new StringBuffer()`시 초기값으로 여유 버퍼를 설정하여 생성하는 것 확인
  - 문자열 추가(`append() or insert()`) 시 배열의 공간을 추가로 늘어나는 것 확인 [테스트](/src/test/java/kr/seok/study/CustomStringBufferTest.java)

- `new StringBuffer()` 신규 생성 시 코드확인
  - StringBuffer 생성자
  ```java
  class CustomStringBuffer {
    // default 생성자 (버퍼의 초기값은 16)
    public CustomStringBuffer() {
      super(16);
    }
  
    // 버퍼 크기 조절 가능한 생성자
    public CustomStringBuffer(int capacity) {
      super(capacity);
    }
  
    // 문자열 저장하여 생성시 문자열의 길이를 고려하여 여유있게 생성
    public CustomStringBuffer(String str) {
      super(str.length() + 16);
      append(str);
    }
  }
  ```

  - `AbstractStringBuilder` 생성자
  ```java
  abstract class AbstractStringBuilder {
      char[] value;
      // StringBuilder의 Constructor
      AbstractStringBuilder(int capacity) {
          value = new char[capacity];
      }
  }
  ```

- StringBuffer `append` 또는 `insert`값 추가시 `배열의 추가 공간 확보 방식`
  - 배열의 추가 공간을 확보하는 방법은 `(기존 buffer + 추가된 입력 문자열의 길이) * 2`를 증가시킨다.
  - 예시
    ```text
    EX) 
    기존 버퍼가 34 였고 현재 버퍼를 32 까지 채운상태인 경우
    append 한 문자열의 길이가 12일 때, 필요한 총 버퍼는 44 이다.
    
    capacity = 34
    length = 32
    append()로 추가한 문자열의 길이 = 12
    
    배열의 추가 버퍼는 새롭게 추가된 문자열의 길이만큼 추가한 뒤 그 두 배를 생성
    44 * 2 = 88
    
    newCapacity = 88
    ```

```java
abstract class AbstractStringBuilder {
    
    // 내부공간 확인 메서드
    private void ensureCapacityInternal(int minimumCapacity) {
        // overflow-conscious code
        if (minimumCapacity - value.length > 0) {
            value = Arrays.copyOf(value, newCapacity(minimumCapacity));
        }
    }

    // 새로운 공간 확보를 위한 필요 공간 확인 메서드
    private int newCapacity(int minCapacity) {
        // overflow-conscious code
        int newCapacity = (value.length << 1) + 2;
        if (newCapacity - minCapacity < 0) {
            newCapacity = minCapacity;
        }
        return (newCapacity <= 0 || MAX_ARRAY_SIZE - newCapacity < 0)
                ? hugeCapacity(minCapacity)
                : newCapacity;
    }

    private int hugeCapacity(int minCapacity) {
        if (Integer.MAX_VALUE - minCapacity < 0) { // overflow
            throw new OutOfMemoryError();
        }
        return Math.max(minCapacity, MAX_ARRAY_SIZE);
    }
}
```
