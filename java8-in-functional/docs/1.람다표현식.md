## 1. 람다표현식

- [습관적인 방법](src/main/java/kr/seok/one/Cities.java)
    - `명령형 버전`
        - city 라는 인스턴스들이 저장되어 있는 컬렉션에서 특정 도시 이름이 있는지 검색하여 값이 존재하면 true, 존재하지 않으면 false를 반환하는 방식
    - `서술적 스타일 버전(declarative)`
        - `contains()`메서드를 사용한 방식

- 위 두 가지 방식으로 `개선된 점`
    - 난잡한 가변변수(Mutable Variable)의 사용을 방지
    - 이터레이션(iteration)을 단계별로 래핑(Wrapping)
      〈역자 주: 이터레이션에 대한 코드가 외부로 드러나지 않기 때문에 개발자는 이터레이션 자체 코드에 대해서는 신경 쓸 필요가 없음〉
    - 어수선한 코드의 사용을 막아줌
    - 코드에 대한 설명이 명확해짐 : 개발자가 원하는 바를 유지할 수 있음
    - 비즈니스 의도는 유지하면서 코드는 명료해짐
    - 오류의 발생 확률을 줄여줌 이해하기 쉽고 유지 보수가 쉬움

- [추가적으로 개선](src/main/java/kr/seok/one/DiscountImperative.java)
    - 너무 자세한 내용까지 코딩되어 있어 로우 레벨 형태의 코드
    - 단일 책임 원칙(Single- Responsibility Principle)을 무시

- [더 나은 방법](src/main/java/kr/seok/one/DiscountFunctional.java)
    - 고차원적인 추상화 방법
    - 메서드들을 파라미터로 익명함수, 람다 표현식을 가지도록 작성

- `더 나은 방법`을 통해 `개선된 점`
    - 코드가 어수선하지 않고 더 짜임새 있게 구셩됨
    - low-level 오퍼레이션을 사용하지 않는다.
    - 로직을 강화하거나 변경하기에 더 쉽다. 메서드를 사용할 때 이터레이션은 라이브러리에 의해 제어된다.
    - 더 효율적이다. 루프에 대한 `레이지 이밸류에이션`(Lazy evaluation)이 가능하다. 원하는 부분을 병렬화하기가 더 쉽다

> 함수형 스타일 코드의 큰 이점

1. `투자대비 높은 효율의 코드를 만듦`
2. `변수의 명시적인 변경이나 재할당의 문제를 피할 수 있다.`

- 변수에 대한 변경이 적다는 것은 코드 안에서 발생할 수 있는 오류의 확률이 더 낮아진다는 것이다.

3. `함수형 버전은 쉽게 병렬화가 가능하다.`

- 하나의 변수에 하나의 오퍼레이션이나 액세스만 가능하다. -> 두 개이상의 오퍼레이션이나 액세스가 발생하지 않도록 한다.
- 이는 스레드 세이프티(thread-safety) 문제를 제거할 수 있다.

4. `서술적인 코드 작성이 가능하다.`

- 간단하게 리스트의 map() 메서드를 사용하여 필요한 기능에 대한 처리가 된 결과 값만을 반환하도록 작성할 수 있다.

5. `함수형 스타일은 직관적이다.`

- 문제의 요구사항을 풀어내는 방식대로 코드를 작성할 수 있도록 도와준다.

> 함수형 스타일로 코딩을 해야 하는 이유

1. 문제의 핵심은 이터레이션(`2장 컬렉션의 사용`)
    - 컬렉션에 있는 엘리먼트를 반복하면서 몇가지 작업을 위해 가변 변수가 만들어진다.
    - 자바는 다양한 오퍼레이션을 위한 특별한 내부 이터레이터를 제공하는데 이를 통해 위의 문제점을 모두 해결할 수 있다.

2. 개발할 때 고려해야하는 정책의 강화(`5장 리소스를 사용한 작업`)
    - 개발 시 트랜잭션의 라이프 타임을 위협하는 코드는 트랜잭션이 정상적으로 동작하는지 매번 확인해야 한다.
    - 함수형 스타일의 코드를 통해 팩토리를 제거하고, 직접 트랜잭션을 처리하도록 바꿀 수 있다.
    - 더 이상 어떤 과정에 대한 실행이 빠졌는지, 예외처리를 빠뜨리지 않았는지 걱정할 필요가 없어진다.

3. 정책 확장하기(`4장 람다표현식을 사용한 데코레이팅`)
    - 일반적으로 확장성에 대한 기본 구조는 하나 이상의 인터페이스, 그 인터페이스를 구현하는 클래스의 계층 구조로 이루어져 있다.
    - 위 와 같은 설계는 유지보수와 추가적인 확장에 어려움을 줄 수 있다.
    - 함수형 인터페이스와 람다 표현식을 사용하는 경우, 확장할 수 있는 정책을 설계하도록 돕는다.
    - 추가적인 인터페이스나 메서드 이름을 따를 필요는 없지만, 제공하려는 코드의 행동(Behavior)에 집중해야 한다.

4. 손쉬운 병렬화
    - 대규모 애플리케이션은 성능 문제가 표면으로 부상했을 때 최종 결과물을 언제 얻을 수 있는지에 대해 민감하다.
    - 이때 여러 모듈에서 성능에 대한 병목현상을 발견하여 멀티스레드 방식으로 개선해야 한다는 걸 알았을 떄, 이를 개선하기 위해서는 엄청난 노력이 필요하다.

5. 스토리텔링(`8장 람다 표현식의 조합`)
    - 비즈니스가 요구하는 바를 코드로 구현하는 데에서 오는 차이로 많은 것들이 사라지고 왜곡될 수 있다.
    - 비즈니스 측면에서 문제를 설명하는 방식대로 코드를 설명할 수 있다.

6. 문제의 분리(`4장 람다를 사용한 문제의 분리`)
    - 애플리케이션에서 공통적으로 필요한 것은 코어 연산과 연산에 필요한 세밀한 로직을 분리하는 것이다.
    - OOP에서는 이러한 방식을 문제의 분리(Separation of Concern)라고 한다.
    - 스트레터지 패턴(Strategy Pattern)을 사용하여 해결한다.
    - 해야 할 일은 한 개 이상의 인터페이스를 만들고 그 인터페이스를 구현하기 위한 몇 개의 클래스를 생성하는 것이다.
    - 위 작업을 더 적은 코드로 구현할 수 있다.
    - 코드 구조 속에서 헤매지 않고 설계 아이디어를 구체화할 수 있다.

7. 이벨류에이션(evaluation)의 지연(`6장 지연 초기화`)
    - 몇 개의 오퍼레이션을 피하거나 적어도 잠시 실행을 연기시키는 것으로 성능을 향상시킬 수 있다.
    - 또한 애플리케이션의 시작과 반응 시간 역시 향상시킬 수 있다.
    - 객체 레퍼런스를 사용하거나 무거운 객체의 초기화를 연기시키기 위해서 Null 체크를 사용하는 것은 너무 어렵다.
    - 새로운 Optional 클래스와 함수형 스타일의 API를 사용하여 개발의 노력을 최소화하고 원하는 것을 더욱 명확하게 할 수 있다.

8. 테스트성 향상시키기(`4장 람다 표현식을 이용한 설계` & `5장 리소스를 사용한 작업`)
    - 변경이 덜한 코드가 오류를 발생시키는 일도 드물다.
    - 람다 표현식은 상당한 수준의 예외 처리 테스트를 만드는 데 도움을 준다.
    - 테스트는 회귀(regression) 방법으로 테스트할 때 필요한 행동(behavior) 중에서 가장 핵심이 되는 테스트 과정을 잡아낸다.
    - 동시에 넘겨진 람다 표현식은 실행될 구현 부분에 대해 한 가지 목적만이 아닌 다양하게 사용될 수 있다.
    - 코드가 실행된 후의 파라미터화 되어 있는 조건에 따라 결과에 대한 컨테이너를 생성 하는 테스트를 만드는데 람다를 사용할 수 있다.

> 혁명이 아닌 진화

- `함수형 스타일에서 얻을 수 있는 이점`
    - 서술적
    - 불변성의 증진
    - 사이드 이펙트 회피
    - 단순 문법보다는 표현에 주력
    - 고차 함수를 사용한 설계

1. 서술적(Be Declarative)
    - 불변 컬렉션(Immutable Collection)에서 contains() 메서드를 서술적으로 사용하는 것이 명령적 스타일을 사용하는 경우보다 코드를 작성하기 쉽다.
